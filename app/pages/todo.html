<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1,minimum-scale=1,maximum-scale=1,user-scalable=no" />
    <title>å¾…åŠäº‹é¡¹</title>
    <link href="../css/mui.min.css" rel="stylesheet" />
    <link href="../css/tailwind.min.css" rel="stylesheet" />
    <script src="../js/mui.min.js"></script>
    <script src="../js/vue.global.js"></script>
    <script src="../js/lodash.min.js"></script>
    <style>
        @font-face {
            font-family: 'JetBrainsMonoNL-Regular';
            src: url('../fonts/JetBrainsMonoNL-Regular.ttf') format('truetype');
        }

        :root {
            --ios-green: rgb(52, 199, 89);
            --ios-orange: rgb(255, 149, 0);
            --ios-red: rgb(255, 59, 48);
            --ios-gray: rgb(142, 142, 147);
            --ios-bg: rgb(242, 242, 247);
            --ios-border: rgb(209, 209, 214);
        }

        body {
            font-family: 'JetBrainsMonoNL-Regular';
        }

        /* iOSé£æ ¼åŠ¨ç”» */
        @keyframes slideIn {
            from {
                transform: translateX(100%);
                opacity: 0;
            }
            to {
                transform: translateX(0);
                opacity: 1;
            }
        }

        @keyframes slideOut {
            from {
                transform: translateX(0);
                opacity: 1;
            }
            to {
                transform: translateX(-100%);
                opacity: 0;
            }
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        @keyframes fadeIn {
            from {
                opacity: 0;
                transform: translateY(10px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        /* iOSé£æ ¼åˆ—è¡¨ */
        .ios-list-item {
            transition: all 0.2s ease;
            position: relative;
            touch-action: pan-y pinch-zoom;
            overflow: hidden;
        }

        .ios-list-item .content {
            transform: translateX(0);
            transition: transform 0.3s ease;
        }

        .ios-list-item .delete-button {
            position: absolute;
            right: 0;
            top: 0;
            bottom: 0;
            width: 80px;
            background: var(--ios-red);
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            font-size: 0.875rem;
            transform: translateX(100%);
            transition: transform 0.3s ease;
        }

        .ios-list-item.swiped .content {
            transform: translateX(-80px);
        }

        .ios-list-item.swiped .delete-button {
            transform: translateX(0);
        }

        .ios-list-item:not(:last-child)::after {
            content: '';
            position: absolute;
            left: 16px;
            right: 16px;
            bottom: 0;
            height: 1px;
            background: linear-gradient(to right,
                transparent 0%,
                var(--ios-border) 50%,
                transparent 100%
            );
        }

        .ios-list-item:active {
            background: rgb(229, 229, 234);
        }

        /* iOSé£æ ¼è¾“å…¥æ¡† */
        .ios-input {
            background: white;
            border: 0.5px solid var(--ios-border);
            border-radius: 10px;
            transition: all 0.2s ease;
        }

        .ios-input:focus {
            border-color: var(--ios-blue);
            box-shadow: 0 0 0 1px var(--ios-blue);
        }

        /* iOSé£æ ¼æŒ‰é’® */
        .ios-button {
            background: var(--ios-orange);
            border-radius: 10px;
            font-weight: 600;
            transition: all 0.2s ease;
        }

        .ios-button:active {
            transform: scale(0.98);
            opacity: 0.9;
        }

        .ios-button:disabled {
            background: var(--ios-gray);
            transform: none;
        }

        /* iOSé£æ ¼å¤é€‰æ¡† */
        .ios-checkbox {
            appearance: none;
            width: 20px;
            height: 20px;
            border: 2px solid var(--ios-border);
            border-radius: 50%;
            transition: all 0.2s ease;
            position: relative;
        }

        .ios-checkbox:checked {
            background: var(--ios-green);
            border-color: var(--ios-green);
        }

        .ios-checkbox:checked::after {
            content: '';
            position: absolute;
            left: 5px;
            top: 2px;
            width: 6px;
            height: 10px;
            border: solid white;
            border-width: 0 2px 2px 0;
            transform: rotate(45deg);
        }

        /* iOSé£æ ¼åˆ é™¤æŒ‰é’® */
        .ios-delete {
            color: var(--ios-red);
            transition: all 0.2s ease;
        }

        .ios-delete:active {
            transform: scale(0.9);
        }

        /* ä¸‹æ‹‰åˆ·æ–°æ ·å¼ */
        .pull-to-refresh {
            position: absolute;
            left: 50%;
            transform: translateX(-50%);
            top: -50px;
            transition: all 0.2s ease;
        }

        /* æ·»åŠ é”®ç›˜ç›¸å…³æ ·å¼ */
        @keyframes slideUp {
            from { transform: translateY(100%); }
            to { transform: translateY(0); }
        }

        .keyboard-open {
            animation: slideUp 0.3s ease-out;
        }

        /* è¾“å…¥æ¡†å®¹å™¨æ ·å¼ */
        .input-container {
            position: fixed;
            left: 0;
            right: 0;
            bottom: 0px;  /* 14rem = 56px */
            backdrop-filter: saturate(180%) blur(20px);
            border-top: 0.5px solid var(--ios-border);
            padding: 12px 16px;
            z-index: 100;
        }

        /* ç¡®ä¿å†…å®¹åŒºåŸŸä¸è¢«é®æŒ¡ */
        .content-container {
            padding-bottom: 120px;  /* ç»™åº•éƒ¨ç•™è¶³ç©ºé—´ */
        }
    </style>
</head>

<body class="font-sans antialiased bg-[--ios-bg] text-gray-900 touch-manipulation">
    <!-- Content -->
    <div class="px-4 max-w-2xl mx-auto min-h-screen content-container" id="app">
        <!-- ä¸‹æ‹‰åˆ·æ–°æç¤º -->
        <div class="pull-to-refresh" :style="{ top: pullDistance + 'px' }" v-if="isPulling">
            <div class="w-6 h-6 border-2 border-[--ios-orange] border-t-transparent rounded-full animate-spin"></div>
        </div>

        <!-- åŠ è½½çŠ¶æ€ -->
        <div v-if="loading" class="flex flex-col items-center justify-center py-12 animate-fadeIn">
            <div class="w-8 h-8 border-2 border-[--ios-border] border-t-[--ios-orange] rounded-full animate-spin mb-4">
            </div>
            <p class="text-[--ios-gray]">åŠ è½½ä¸­...</p>
        </div>

        <!-- é”™è¯¯çŠ¶æ€ -->
        <div v-else-if="error" class="text-center py-12 animate-fadeIn">
            <div class="text-[--ios-gray] text-5xl mb-4">âš ï¸</div>
            <p class="text-[--ios-gray] mb-4">{{ error }}</p>
            <button
                class="px-6 h-10 ios-button text-white"
                @click="fetchTodos">
                é‡è¯•
            </button>
        </div>

        <!-- å¾…åŠåˆ—è¡¨ -->
        <div v-else class="space-y-0">
            <div v-for="(todo, index) in todos" :key="todo._id"
                class="ios-list-item animate-[fadeIn_0.3s_ease-out]"
                :class="{ 
                    'animate-[slideOut_0.3s_ease-out]': todo.isDeleting,
                    'swiped': swipedTodoId === todo._id 
                }"
                @touchstart="handleItemTouchStart($event, todo._id)"
                @touchmove="handleItemTouchMove($event, todo._id)"
                @touchend="handleItemTouchEnd(todo._id)"
                @touchcancel="handleItemTouchEnd(todo._id)">
                <div class="content p-3">
                    <div class="flex items-center gap-3">
                        <input type="checkbox" 
                            :checked="todo.completed"
                            @change="toggleTodo(todo._id)"
                            class="ios-checkbox">
                        <span :class="['flex-1 text-base', todo.completed ? 'line-through text-[--ios-gray]' : 'text-gray-800']">
                            {{ todo.title }}
                        </span>
                    </div>
                </div>
                <div class="delete-button" @click="deleteTodo(todo._id)">
                    åˆ é™¤
                </div>
            </div>
        </div>

        <!-- ç©ºçŠ¶æ€ -->
        <div v-if="!loading && !error && todos.length === 0" class="text-center py-12 animate-fadeIn">
            <div class="text-[--ios-gray] text-5xl mb-4">ğŸ“</div>
            <p class="text-[--ios-gray]">è¿˜æ²¡æœ‰å¾…åŠäº‹é¡¹</p>
        </div>

        <!-- åº•éƒ¨è¾“å…¥æ¡† -->
        <div class="input-container" :class="{ 'keyboard-open': isKeyboardOpen }">
            <div class="flex gap-2 max-w-2xl mx-auto">
                <input type="text" v-model="newTodo" 
                    class="flex-1 px-4 h-10 ios-input text-lg"
                    placeholder="æ·»åŠ æ–°çš„å¾…åŠäº‹é¡¹"
                    @keyup.enter="addTodo"
                    @focus="isKeyboardOpen = true"
                    @blur="isKeyboardOpen = false"
                    :disabled="loading">
                <button @click="addTodo"
                    class="px-6 h-10 ios-button text-white text-lg disabled:opacity-50 disabled:cursor-not-allowed"
                    :disabled="loading">
                    æ·»åŠ 
                </button>
            </div>
        </div>
    </div>

    <script type="text/javascript">
        document.addEventListener("plusready", function () {
            plus.webview.currentWebview().setStyle({
                bounce: "vertical",
            });

            mui.init();

            const { createApp, ref, onMounted } = Vue;
            const API_BASE_URL = "http://159.138.131.5:8899/api/v1";

            const app = createApp({
                setup() {
                    const todos = ref([]);
                    const newTodo = ref("");
                    const loading = ref(false);
                    const error = ref(null);
                    const pullDistance = ref(0);
                    const isPulling = ref(false);
                    const swipedTodoId = ref(null);
                    const isKeyboardOpen = ref(false);
                    let startX = 0;
                    let currentX = 0;
                    const SWIPE_THRESHOLD = 40;

                    // è§¦è§‰åé¦ˆ
                    const vibrate = () => {
                        if (plus.os.name === 'iOS') {
                            plus.device.vibrate();
                        }
                    };

                    // ä¸‹æ‹‰åˆ·æ–°ç›¸å…³
                    const handleTouchStart = (e) => {
                        startX = e.touches[0].pageY;
                    };

                    const handleTouchMove = (e) => {
                        const currentY = e.touches[0].pageY;
                        const distance = currentY - startX;

                        if (distance > 0 && window.scrollY === 0) {
                            pullDistance.value = Math.min(distance * 0.5, 60);
                            isPulling.value = true;
                            e.preventDefault();
                        }
                    };

                    const handleTouchEnd = async () => {
                        if (pullDistance.value > 40) {
                            vibrate();
                            await fetchTodos();
                        }
                        pullDistance.value = 0;
                        isPulling.value = false;
                    };

                    // APIè¯·æ±‚å°è£…
                    const api = {
                        async request(url, options = {}) {
                            try {
                                const response = await fetch(`${API_BASE_URL}${url}`, {
                                    headers: {
                                        "Accept": "application/json",
                                        "Content-Type": "application/json",
                                    },
                                    mode: "cors",
                                    ...options,
                                });

                                const data = await response.json();

                                if (!response.ok) {
                                    throw new Error(data.error?.message || "è¯·æ±‚å¤±è´¥");
                                }

                                return data;
                            } catch (err) {
                                console.error("APIè¯·æ±‚é”™è¯¯:", err);
                                throw err;
                            }
                        },

                        getTodos() {
                            return this.request("/todos");
                        },

                        createTodo(title) {
                            return this.request("/todos", {
                                method: "POST",
                                body: JSON.stringify({ title }),
                            });
                        },

                        updateTodo(id, data) {
                            return this.request(`/todos/${id}`, {
                                method: "PUT",
                                body: JSON.stringify(data),
                            });
                        },

                        deleteTodo(id) {
                            return this.request(`/todos/${id}`, {
                                method: "DELETE",
                            });
                        },
                    };

                    const fetchTodos = async () => {
                        loading.value = true;
                        error.value = null;

                        try {
                            const response = await api.getTodos();
                            todos.value = response.data.data;
                            vibrate();
                        } catch (err) {
                            error.value = "è·å–å¾…åŠåˆ—è¡¨å¤±è´¥,è¯·æ£€æŸ¥ç½‘ç»œè¿æ¥";
                        } finally {
                            loading.value = false;
                        }
                    };

                    const addTodo = async () => {
                        if (!newTodo.value.trim() || loading.value) return;

                        loading.value = true;
                        try {
                            const response = await api.createTodo(newTodo.value.trim());
                            todos.value.unshift(response.data);
                            newTodo.value = "";
                            vibrate();
                            mui.toast("æ·»åŠ æˆåŠŸ");
                        } catch (err) {
                            mui.toast("æ·»åŠ å¤±è´¥");
                        } finally {
                            loading.value = false;
                        }
                    };

                    const toggleTodo = async (id) => {
                        const todo = todos.value.find(t => t._id === id);
                        if (!todo || loading.value) return;

                        const originalState = todo.completed;
                        todo.completed = !originalState;

                        try {
                            await api.updateTodo(id, { completed: todo.completed });
                            vibrate();
                        } catch (err) {
                            todo.completed = originalState;
                            mui.toast("æ›´æ–°å¤±è´¥");
                        }
                    };

                    const deleteTodo = async (id) => {
                        if (loading.value) return;

                        const todo = todos.value.find(t => t._id === id);
                        if (!todo) return;

                        todo.isDeleting = true;
                        vibrate();

                        try {
                            await api.deleteTodo(id);
                            await new Promise(resolve => setTimeout(resolve, 300)); // ç­‰å¾…åŠ¨ç”»å®Œæˆ
                            todos.value = todos.value.filter(t => t._id !== id);
                            mui.toast("åˆ é™¤æˆåŠŸ");
                        } catch (err) {
                            todo.isDeleting = false;
                            mui.toast("åˆ é™¤å¤±è´¥");
                        }
                    };

                    const handleItemTouchStart = (e, todoId) => {
                        if (swipedTodoId.value && swipedTodoId.value !== todoId) {
                            swipedTodoId.value = null;
                        }
                        startX = e.touches[0].clientX;
                        currentX = startX;
                    };

                    const handleItemTouchMove = (e, todoId) => {
                        currentX = e.touches[0].clientX;
                        const deltaX = currentX - startX;
                        
                        if (deltaX < 0) {
                            e.preventDefault();
                            if (Math.abs(deltaX) > SWIPE_THRESHOLD) {
                                swipedTodoId.value = todoId;
                            }
                        } else if (swipedTodoId.value === todoId) {
                            swipedTodoId.value = null;
                        }
                    };

                    const handleItemTouchEnd = (todoId) => {
                        const deltaX = currentX - startX;
                        if (Math.abs(deltaX) < SWIPE_THRESHOLD && swipedTodoId.value === todoId) {
                            swipedTodoId.value = null;
                        }
                    };

                    onMounted(fetchTodos);

                    return {
                        todos,
                        newTodo,
                        loading,
                        error,
                        pullDistance,
                        isPulling,
                        addTodo,
                        toggleTodo,
                        deleteTodo,
                        fetchTodos,
                        handleTouchStart,
                        handleTouchMove,
                        handleTouchEnd,
                        swipedTodoId,
                        handleItemTouchStart,
                        handleItemTouchMove,
                        handleItemTouchEnd,
                        isKeyboardOpen,
                    };
                }
            });

            app.mount("#app");
        });
    </script>
</body>
</html> 